# .NET

## .NET OVERVIEW
* .NET is a developer platform made up of tools, programming languages, and libraries for building many different types of applications
* The base platform provides components that apply to all different types of apps and multiple languages, including basic libraries (strings etc), editors, and the C#, F# and Visual Basic programming languages
* all .NET programs are compiled into a CIL (Common Intermediate Language) that is then translated to machine code and executed

### COMMON LANGUAGE RUNTIME
* when a dotnet app is built, regardless of what language the app is written in, it all gets compiled into a common "dotnet speak" -- the IL (intermediate language) is stored in the .exe or .dll generated by the build
* when the app is executed, the CLR's just in time (JIT) compiler converts the intermediate language to machine code -- there is a header in the executable that loads the .NET CLR, and the .NET CLR JIT compiles the IL to native code for the CPU. the native code is cached for CPU execution
* this is how you're able to run programs written in many different languages without your computer "speaking" F#
* the CLR includes services such as thread management, garbage collection, type safety and exception handling. it also provides security boundaries
* code that is managed by the CLR is called **managed code**
* developers working on **unmanaged code** must handle all these concerns manually. additionally, code compiled on one architecture can only be run on that arch -- it must be recompiled for other environments
	- more control over memory allocation, bypass restrictions, closer to CPU architecture
	- typical for C and C++ development
	- C# can be unmanaged but it's not common

### WHY .NET?
* .NET is a popular choice for medium to large scale enterprise applications
* .NET is maintained by Microsoft, so it is frequently updated and maintained, and it is well-documented

### FRAMEWORK
* the original implementation of .NET
* supports development of websites, services, desktop apps and more
* only supports Windows -- fairly tightly coupled to Windows and IIS
* includes the CLR and Class Library
* Framework is currently at 4.8 and will be supported but will not be developed further

### .NET CORE
* an open-source, cross-platform reimagination of the common layer below all languages -- the basis of Core is the CLR Core
* this strips a lot of backwards compatibility for things we don't need anymore -- this fresh start allows for much greater performance
* Core still uses the same abstractions, same languages as .NET Framework instances that compile to a CLR Core, it just does a lot less stuff, faster
* by Core 3, we have most of the functionality that we have in .NET
* still missing some things in Core like WCF (which is still supported in Framework)
* confusingly, we skipped Core 4 and what would be Core 5 is now known as just .NET 5 ðŸ™„
* Core can be used with Docker, and it includes command line tools for local development and continuous integration

### ASP.NET
* ASP == "Active Server Pages"
* ASP.NET extends the .NET platform with tools and libraries specifically for building server-side web apps, including MVC apps and APIs
* includes
	- request processing framework
	- Razor web page templating
	- common web pattern libraries like MVC
	- authentication system
	- editor extensions for working with web pages

### .NET STANDARD
* Standard is a specification of .NET, rather than an implementation -- it is a successor of the portable class library
* it defines the set of APIs that all .NET implementations must provide
* kind of like another .NET Framework, but it is only used to develop class libraries -- it is a "bridge" between these different abstraction layers
* example: you use Standard to write a shared library that is consumed by both Framework and Core applications (specifically you use Standard 2.0 as Standard 1.x is not supported by Core)
* Standard can also be used to "bridge" between things like Xamarin, Mono and Unity
* Standard will eventually be obsolesced once we no longer need to cross the bridge -- since the new .NET 5+ will be cross-platform compatible, mobile etc, we won't need to translate anymore

### XAMARIN/MONO
* .NET implementations for mobile OS

### ENTITY
* object-database mapper
* abstraction layer that maps model classes to a database, reducing the amount of code that needs to be written
* friendly with SSMS, MySQL, psql, SQLite and more


## PROJECT FOLDER STRUCTURE
* depends on your purpose, but general stuff includes:
	- `/Properties/launchsettings.json`: tells the framework how to launch the app, including what commands to run, env variables to set, and applications (such as browser) to launch. **THIS IS WHERE YOUR LOCALHOST URL IS SET!**. this info is also used for debugging
	- `Startup.cs`: provide configurations for how the app should start and execute
	- `Program.cs`: .NET Core is a console application configured to run a web app -- Program.cs contains the `main` method
	- `appsettings.json`: connection and app-specific settings, globally scoped variables. env-specific settings files can be created, such as `appsettings.Development.json`
	- `MyProject.csproj`: an XML file

## .NET CORE => .NET6+ AND NEW STUFF
* C# 10+ allows for the omission of the program class and the `Main` method -- whether you use them or not is up to you if your app doesn't take command line args


## MVC
* **model**: the data model that is ultimately displayed in the view. model is responsible for communicating with the db
* **controller**: a layer between the view and the model; keeps secret stuff in the model hidden
* **view**: the UI of the app, consisting of HTML, CSS and JS. displays the data sourced from the model by calling the controller

### MODEL
* model classes consist of the data properties as well as setters and getters
* providing an `ID` property allows Entity to automatically detect it as a PK. PK can also be marked with `[Key]` attribute
* **data attributes** and **validation** can be used to ensure that models (specifically models being used to set data) are correclty populated
* you can use a SeedData method to populate data for testing [like this](https://www.educative.io/module/page/El5jyzfgAE0VAoo8r/10370001/6078451431243776/5415907997777920)

### CONTROLLERS
* Controller classes must implement the `IController` interface -- to acheive this, your controller should just inherit `Controller` to get support for views
* `_context` can be used throughout your controller classes to access your httpContext and database context
* **Action methods** are the methods within a controller -- the name of the method is used to map to its URL endpoint, e.g. the `Details()` method in `UserController` maps to `/User/Details`
* action methods can have a few different return types:
	- `ActionResult`: returns an object or exception
	- `IActionResult`: contract to represent the result of an action method. the default implementation of `IActionResult` is `ActionResult`
	- `Task<>` represents an operation that executes asynchronously
	- `Task<IActionResult>` returns results from action methods asyncronously



## DEPENDENCY INJECTION
* DI is a built-in part of the Core framework
* services/dependencies are registered in a service container: `IServiceProvider`
* services are registered on app start up and appended to an `IServiceCollection`
* once all the services are added, `BuildServiceProvider` creates the service container which supplies the dependencies
* the service *injects* the service to the construcotr of the class where it's needed -- it is responsible for creating an instance of that dependency and disposing of it when it's no longer needed

### SCOPES
* the method used to register a service indicates the scope (lifetime) of an instance
* **transient**: a new instance will be created every time it is requested
	- used for lightweight operations with very little or no state
	- ex: httpclient: you get a fresh one each time because your request is (probably) different
* **scoped**: a new instance is created for each scope (each server request)
	- used when some amount of state is needed throughout a request
	- ex: sql connection
* **singleton**: a single instance will be created
	- must be memory tight and efficient as it's used everywhere for a long time (leaks build up)
	- ex: logger, memory cache

## WEB APPLICATION

## WEB API
*



## DOTNET CLI
*

```sh
## GENERAL

# check what sdks are installed
dotnet --list-sdks

## PROJECTS

# create a new webApi named SimpleApi in a folder of the same name
dotnet new webapi -o SimpleApi

# add a gitignore with default content to your project
dotnet new gitignore

# builds a project and all its dependencies
dotnet build

# first builds and then runs the application
dotnet run

# install package foo and make it available to your code
dotnet install package foo


## MANAGE PACKAGES
# add package
dotnet add package Microsoft.EntityFrameworkCore.InMemory

# specify package source
dotnet add package CCI.Communications.Client -s https://www.myprivatesource.com/api/v2/


```

